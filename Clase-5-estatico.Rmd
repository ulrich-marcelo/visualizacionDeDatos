---
title: "Clase 5 - Gramática de los gráficos en R"
author: 
  - Licenciatura en Ciencias de Datos - UNSAM
  - Visualización de datos en R
  - Septiembre 2025
  - Florencia Piñeyrúa
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    theme: journal
---

```{r, include=FALSE}
library(tidyverse)
library(ggplot2)
library(plotly)
library(leaflet)
library(sf)
library(gganimate)
library(gifski)
library(dplyr)
library(forcats)

# Datos de temperatura, cortesía de https://www.kaggle.com/sudalairajkumar/daily-temperature-of-major-cities
load(file='./data/temps.rda')
temps_beirut <- temps[temps$city == "Beirut",]
load("./data/gapminder.rda")


```

# Introducción

El paquete [**ggplot2**](https://ggplot2.tidyverse.org/) forma parte del conjunto de librerías llamado `tidyverse`.

En esta clase vamos a abordar los elementos necesarios para representar un gráfico con ggplot2.

Uno de ello es la asignación (*mapping* en inglés) de atributos estéticos a los valores que toma una variable. 

¿Cómo mostrar de modo perceptible a la vista la diferencia entre valores? Generalmente lo hacemos describiendo posiciones de un valor "x" y un valor "y". También podemos definir un tamaño, una forma o un color.

![](./img/aes.png){width="68%"}
```{r , echo = TRUE, eval = FALSE}
# cargar la librería que vamos a usar
library(ggplot2)
```


Los elementos necesiarios para representar un gráfico en ggplot2 son:

1. Un data frame que contiene los datos que se quieren visualizar.

2. Los atributos estéticos (*aesthetics* en inglés) que especifica las relaciones entre variables y los atributos estéticos con los cuales se representar sus valores (como el color, el tamaño, la transparencia, la forma la línea, entre otros).

3. Los geoms que especifican los elementos geométricos, es decir, la geométria del gráfico (puntos, líneas y/o círculos).



El data set con el que practicaremos contiene la temperatura promedio para cada día del 2019 en la ciudad de Beirut, Líbano:

```{r}
temps_beirut
```

## Uso básico de `ggplot`

Si le pasamos un dataframe a `ggplot()`, sin agregar nada más, obtenemos un gráfico vacío:

```{r}
ggplot(temps_beirut)
```

¡Vendría a ser una especie de lienzo en blanco!

Esto es porque necesitamos definir al menos una geometría (el recurso visual con el que vamos a mostrar la información, como ser un gráfico de líneas, puntos, barras) y una asignación estética (una lista de relaciones entre las variables del data frame y determinados aspectos del gráfico, por ejemplo coordenadas x e y, formas o colores).



`ggplot()` implementa un marco teórico para la creación de visualizaciones, ["la gramática de los gráficos"](https://www.slideshare.net/0xdata/leland-wilkinson-h2oai-the-grammar-of-graphics-and-the-future-of-big-data-visualization-h2o-world-2019-nyc), que permite expresar en forma concisa los componentes de un gráfico:

![](./img/ggplot_resumen.png){width="79%"}

¿Cómo funciona ésto en la práctica? El caso de uso más simple de ggplot consiste en:

-   una llamada a la función `ggplot()`, pasándole un dataset y una "asignación de atributos estéticos" (*aesthetic mapping* en inglés) usando `aes()`
-   al menos una capa "geom", que define el recurso gráfico que mostrará los datos; por ejemplo `geom_line()` para dibujar líneas o `geom_point()` para dibujar puntos.

A intentarlo. Asignemos la columna `day_of_year` a la posición en el eje de las $x$, la columna `temperature` a las $y$, y usemos `geom_line()` para mostrar los datos.


```{r}
ggplot(temps_beirut, aes(x = day_of_year, y = temperature)) +
  geom_line()
```

Ahora otra vez, pero usando `geom_point()` en vez de `geom_line()`.

```{r}
ggplot(temps_beirut, aes(x = day_of_year, y = temperature)) +
  geom_point()
```

Y ahora intercambiemos las columnas que antes asignamos a las $x$ y a las $y$:

```{r}
ggplot(temps_beirut, aes(x = temperature, y = day_of_year)) +
  geom_point()
```

## Empelando *geoms* más complejas

Pueden elegir entre una variada colección de geoms para hacer toda clase de gráficos. Por ejemplo, `geom_boxplot()` crea *boxplots* (o ["diagramas de caja"](https://economipedia.com/definiciones/diagrama-de-caja.html)). 
Al hacer boxplots es común mostrar un gráfico separado para cada categoría presente en la data a mostrar, usando para eso el eje de las $x$ o de las $y$. 

¡Hagamos eso mismo! Pongamos `month` en el eje $x$ (como variable categórica), `temperature` en el eje de las $y$, y a dibujar cajas con `geom_boxplot()`.

```{r}
ggplot(temps_beirut, aes(x = month, y = temperature)) +
  geom_boxplot()
```

¿Qué pasa si lo damos vuelta?

```{r}
ggplot(temps_beirut, aes(x = temperature, y = month)) +
  geom_boxplot()
```


## Incorporando colores a las visualizaciones

Ahora pasamos a trabajar con el dataset `temps`, que es similar a `temps_beirut` pero contiene registros para tres ubicaciones adicionales: 

```{r}
temps
```

Hagamos un gráfico de líneas mostrando `temperature` para cada `day_of_year`, usando el atributo estético *color* para diferencias las líneas según la ciudad que representan.

```{r}
ggplot(temps, aes(x = day_of_year, y = temperature, color = city)) +
  geom_line()+
  scale_color_viridis_d()
```

Vamos de nuevo, esta vez usando `city` como variable en el eje $y$, y `temperature` a representar con color. Este gráfico queda mejor usando `geom_point()`.

```{r}
ggplot(temps, aes(x = day_of_year, y = city, color = temperature)) +
  geom_point()
```

En estos dos ejemplos utilizamos el color como atributo estético para mostrar información. Sin embargo, lo estamos haciendo de dos formas muy distintas. En el gráfico de líneas, usamos el color como una herramienta para *distinguir* variables categóricas. Mientras que en el gráfico de puntos, lo usamos para representar una escala secuencial de valores. Dicha escala permite indicar de manera clara qué valores son más grandes que otros, y qué tan distantes son los valores entre sí.

Los colores que elijamos en un gráfico van a transmitir un mensaje y tienen poder ser interpretados para el público general. Por ejemplo, no es lo mismo si en un gráfico pinto la barra de mujeres de rosa y la de varones de azul; que si las pinto naranja y verde. Por otro lado, hay ciertos colores que dificultan la interpretación para las personas con daltonismo.

Por suerte, R tiene paquetes con paletas de colores que nos permiten resolver algunas de estas cuestiones. Uno de los más popular es `viridis`, cuya paleta de colores están diseñadas para ser:

-   coloridas, brindando una paleta amplia para mostrar diferencias con claridad;
-   perceptualmente uniformes, lo que significa que los valores más cercanos entre ellos tendrán colores más parecidos y los que están más alejados tendrán colores distintos de manera consistente;
-   interpretados fácilmente por personas con daltonísmo; 
-   interpretables si se imprimen en escala de grises.

Usar las paletas viridis es tan simple como añadir una línea de código:

```{r message=FALSE, warning=FALSE}
library(viridis)

ggplot(temps, aes(x = day_of_year, y = city, color = temperature)) +
  geom_point()+
  scale_color_viridis_c()
```


Existe una amplia variedad de paquetes con paletas de colores. [`wesanderson`](https://github.com/karthik/wesanderson), con colores de películas de Wes Anderson, o [`SailorMoonR`](https://github.com/morgansleeper/SailorMoonR) con colores de Sailor Moon.


# Más allá del aspecto que tienen los gráficos de ggplot *por defecto*
## Puliendo nuestras visualizaciones para su publicación

El paquete ggplot toma decisiones por default cuando genera un gráfico o visualización. Por ejemplo, el color de los ítems con los que representa los datos, el rango numérico de los ejes (en que número empiezan y terminan) o el color de fondo. Lo anterior, permite realizar visualizaciones rápidas escribiendo pocas líneas de código. Sin embargo, a la hora de compartir nuestras visualizaciones con el mundo vale la pena hacer ajustes para obtener mejores resultados.

![](./img/ggplot.png){width="97%"}


El data set con el que trabjaremos esta clase fue compilado por [Gapminder](https://www.gapminder.org/), una ONG sueca dedicada a explicar el mundo con datos. La base de datos contiene indicadores de desarrollo de países en todo el mundo, con observaciones en intervalos de 5 años:

```{r}
head(gapminder)
```

## Inspirandonos en un famoso gráfico

Los gráficos de dispersión o *scatterplots* son quizás el tipo de visualización más conocido. 

Los gráficos de dispersión visualizan la relación entre dos variables numéricas, de forma que una variable se muestra en el eje x y la otra, en el eje y. En otras palabras, consiste en puntos proyectados en un eje de coordenadas ("x" e "y"), donde cada punto representa una observación. Estos gráficos son útiles para mostrar la correlación entre dos variables numéricas.

Por ejemplo, podríamos comparar la relación entre la riqueza de los países (medida como PBI per capita) y la salud de sus habitantes (como expectativa de años de vida). Esa es la visualización de datos que popularizó Hans Rosling.

![](./img/hans.png){width="80%"}

Hans Rosling fue el médico, fanático de la estadística, optimista y entusiasta comunicador que fundó el proyecto Gapminder, cuya misión declarada es "luchar contra la ignorancia devastadora con una visión del mundo basada en hechos, que todo el mundo pueda entender".

Antes de seguir, dediquemos cuatro minutos a mirar ["200 años, 200 países, 4 minutos"](https://www.youtube.com/watch?v=dfa7B8LPGOE), un resumen ilustrado de los últimos dos siglos de desarrollo económico que Rosling preparó con ayuda de la BBC.

Intentemos reproducir la visualización de Rosling. Con lo que aprendimos hasta aquí, deberíamos poder realizar un gráfico de dispersión básico -con `geom_point()`- ubicando la variable "PBIpc" en el eje de las $x$, y "expVida" en el eje de las $y$:

```{r}
ggplot(gapminder, aes(x = PBIpc, y = expVida)) +
  geom_point()
```

Hmmm... ¡no se ve muy parecido!. 


## Escalas logarítmicas

Lo que ocurre es que Rosling utiliza un truco: usa una escala logarítmica. 

Si revisamos la imagen de Rosling presentando que aparece más arriba, vemos que en el eje de las $y$ la escala salta de 400 a 4.000 y luego a 40.000. En segmentos del mismo largo, los valores no crecen proporcionalmente sino en potencias de 10. Esto se logra tomando el logaritmo en base 10 de los datos antes de proyectarlos, con lo cual lo que estamos mostrando es 4 x 10^1^, 4 x 10^2^, 4 x 10^3^, etc. 

¿Para que sirve esto? Para visualizar datos en los que existen grandes disparidades en una variable, porque permite que los valores pequeños tengan espacio para diferenciarse y, a la vez, que los valores grandes no aparezcan tan alejados. Logrando, de esta manera, un gráfico más compacto y en general más legible. 

Cuando hay dinero involucrado suele ser necesario invocar a la escala logarítmica para mejorar la legibilidad... ¡las grandes disparidades abundan!

En todo caso, `ggplot2` incluye varias funciones para transformar las escala de las $x$ o de las $y$, entre ellas las que pasan las variables a escala logarítmica de base 10: `scale_x_log10()` y `scale_y_log10()`. ¿Cual usaríamos aquí?

```{r}
ggplot(gapminder, aes(x = PBIpc, y = expVida)) +
  geom_point() +
  scale_x_log10()
```

Las funciones que empiezan con `scale_y_` o `scale_x_` generalmente sirven para modificar valores en una escala. A su vez, tiene varios parámetros modificables. Por ejemplo, tenemos el parámetro `labels` en el cual puedo especificar las etiquetas del eje. Con la ayuda del paquete `scales` podemos mostrar nuestros valores como números con comas.

```{r}
ggplot(gapminder, aes(x = PBIpc, y = expVida)) +
  geom_point() +
  scale_x_log10(labels=scales::comma)

```

Ahora se vislumbra una disposición similar a la del gráfico del video, pero en nuestro caso parece haber demasiados puntos. Esto es porque nuestra data incluye 12 observaciones para cada país (cada 5 años desde 1952 hasta 2007). ¡O sea que cada país aparece 12 veces! El Dr. Rosling usaba sólo un punto por país, usando animación para mostrar distintos años.

Vamos a filtrar los datos para quedarnos sólo con la observación más reciente disponible, la de 2007. Existe muchas formas de hacer esto en R, pero aquí vamos a usar la función `filter()` del paquete [dplyr](https://dplyr.tidyverse.org/). 

Si no conocen esta herramienta, o necesitan un repaso rápido, pueden revisar ["transformando los datos"](https://bitsandbricks.github.io/ciencia_de_datos_gente_sociable/poniendo-los-datos-en-forma.html#transformando-los-datos). 

Por ahora la vamos a usar de forma muy simple: en lugar de llamar a la variable gapminder, vamos a usar el resultado de filtrar su contenido de forma tal que solo usemos las filas donde la variable "año" toma el valor *2007*.

Activamos el paquete `dplyr`

```{r echo = TRUE, eval=FALSE}
library(dplyr)
```

Y ahora ya podemos usar su función `filter()` para modificar nuestro dataset:

```{r plotminder3, echo=TRUE}
ggplot(filter(gapminder, año == 2007), aes(x = PBIpc, y = expVida)) +
  geom_point() +
  scale_x_log10()
```

## Intervalo de confianza

Ahí va queriendo. Desviándonos un poco de nuestro objetivo original de replicar a nuestro amigo Hans, podríamos querer agregar un intervalo de confianza para nuestros puntos. Esto lo podemos lograr con `geom_smooth()`.

```{r}
ggplot(filter(gapminder, año == 2007), aes(x = PBIpc, y = expVida)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10()
```

`geom_smooth()` me muestra una línea de tendencia de las observaciones en el gráfico con el intervalo de confianza para cada grupo. Cuantas menos observaciones tenga para cada grupo, más grande será el intervalo. Se pueden aplicar distintas funciones para aplicar la línea de tendencia.

Necesitamos dos ajustes más para que el parecido sea evidente. Rosling usa el tamaño de los puntos para indicar la población del país y el color para diferenciar entre continentes. Con lo que aprendimos en la clase anterior podemos animarnos: las variables que se mostrarán con esos atributos estéticos son "pobl" y "continente"

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl, color = continente)) +
  geom_point() +
  scale_x_log10()
```

¡Eso si es un plot *gapmindereano*!

¿Qué pasaría si quisieramos agregar un intervalo de confianza en este gráfico?

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl, color = continente)) +
  geom_point() +
  geom_smooth(method = "lm")+ 
  scale_x_log10()
```

:( ¿Por qué no se ve como quisieramos?

Esto tiene que ver con el mapeo de las observaciones. En la primera línea de ggplot definimos que queríamos que los atributos de color y tamaño se mapeen para todas las geometrías que tenemos. De esta manera, `geom_smooth()`\` está haciendo la línea de tendencia para todos los grupos por su color. Por ello, si queremos mantener la tendencia global debemos hacer unos pequeños ajustes en nuestro gráfico.

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida)) +
  geom_point(aes(size = pobl, color = continente)) +
  geom_smooth(method = "lm")+
  scale_x_log10()
```

Pero esto no termina aquí. Quedan bastantes cosas para ajustar antes de que nuestro querido gráfico esté listo para ser compartido con el mundo.


## Eliminando leyendas

En el video de la BBC, la visualización se presenta sin leyendas para reducir al mínimo el texto en pantalla y que se pueda mirar como casi un cuadro. Para eliminar leyendas en nuestro ggplot podemos usar `guides` y dentro asignar el valor `"none"` a cada atributo estético para el cual no queremos leyenda. Por ejemplo, `color = "none"`. 

¿Cómo eliminamos la leyenda de los atributos color y tamaño?

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl, color = continente)) +
  geom_point() +
  scale_x_log10() +
  guides(size = "none", color = "none")
```

## Lidiando con números grandes

Con frecuencia preferimos quedarnos con la leyenda para invitar que la audiencia compare los valores representados. En ese caso es necesario asegurarse que los valores mostrados sean razonablemente fáciles de interpretar.

En nuestro gráfico, algo que podemos mejorar es la representación de los números muy grandes: los millones de personas de la población. Por defecto, R usa notación científica para abreviar los números muy grandes (o muy anchos, deberíamos decir: los números ínfimos, con muchos espacios decimales en cero, también se abrevian). 

Por eso en nuestro gráfico aparecen valores como "1.25e+09", que significa "1,25 \* 10 elevado a la 9", o sea 1.250 millones. La brevedadad es buena a la hora de comunicar, pero no cuando se trata de números - la escala para la variable de población, en notación científica, resulta muy difícil de interpretar para la mayoría de las personas:

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl, color = continente)) +
  geom_point() +
  scale_x_log10() 

```

Se puede hacer que R se abstenga de abreviar usando la notación científica (ejecutando la línea `options(scipen=999)`). Pero una solución aún mejor, cuando de visualización se trata, es la de convertir unidades. Por ejemplo, si los valores de población alcanzan valores tan grandes, representemos *millones* de personas y con eso los valores van a ser mas pequeños: en lugar de mostrar 1.000.000, ahora veremos solo "1" (porque la unidad es "millones de habitantes").

Entonces nos quedamos con las leyendas (ya no las deshabilitamos con `guides()`), y le podemos pedirle a ggplot que el tamaño de los puntos ya no represente los valores de la columna "pobl", si no el resultado de los valores de la columna divididos por un millón. ¿Cómo sería?

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() +
  scale_x_log10()
```

## Eligiendo colores a mano

Si comparamos nuestros resultados con los de la visualización televisada por la BBC, notaremos que los colores usados para representar la variable "continente" son distintos. Esto es porque Rosling y su equipo los eligieron a su gusto, mientras que nosotros estamos usando los colores que elige ggplot de forma automática.

Al cumplirse un [minuto del video](https://youtu.be/jbkSRLYSojo?t=62) oímos a Hans nombrar los colores que usa: "Europe brown, Asia Red...". Con eso podemos armar una lista con valores y sus colores asignados para pasarle a `ggplot()`.

Tomándonos nada menos que tres licencias. No vamos a asignarle un color específico a los países del Medio Oriente porque no aparecen diferenciados en nuestra data. Vamos a elegir un color para los dos países de Oceanía que tenemos y para Europa vamos a elegir un naranja oscuro, porque ese parece ser el color que usaron en lugar de marrón.

En R tenemos 657 colores que podemos llamar por nombre, como "hotpink" o "aquamarine". Como es imposible recordarlos a todos, se puede recurrir a una [guía de colores](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) para encontrar los que necesitamos. Habiendo identificado nuestros colores, definimos la escala manual así:

```{r echo=TRUE}
color_continentes <- c("Europe" = "darkorange", "Asia" = "red", "Africa" = "blue",
                       "Americas" = "yellow", "Oceania" = "purple")
```

Y luego podemos usarla para indicarle a ggplot los colores exactos que queremos usar. Para eso sirve `scale_color_manual()`, con su parámetro "values". Probemos:

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes)
```

## Cambiando el "tema"

Hasta aquí hemos podido ajustar los atributos gráficos que dependen estrechamente de los datos, como las escalas, los colores y los tamaños. 

¿Pero que hay de otros componentes visuales que podríamos cambiar, como la tipografía y su tamaño o el color de fondo?
Esos atributos corresponden al "tema" (*theme* en inglés) que apliquemos. Los temas son como "packs" de parámetros que definen el aspecto de todos los componentes no relacionados con los datos y pueden cambiar drásticamente el *look* de nuetros gráficos. 

El paquete `ggplot2` incluye varias funciones que aplican [temas predefinidos](https://ggplot2.tidyverse.org/reference/ggtheme.html), como "theme_dark()" (la opción por defecto), "theme_dark", "theme_void", "theme_minimal", etc. Por eso para usar los temas alcanza con sumar una línea que llame a la función correspondiente. Por ejemplo, para usar "theme_dark":

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_dark()
```

Incluso podemos definir a mano cada componente visual de los gráficos creando así nuestro propio tema. El camino comienza por el uso de la [función `theme`](https://ggplot2-book.org/polishing.html#modifying-theme-components). Si entramos a la documentación vemos que tenemos *muchos* parámetros que podemos modificar en ella, por lo que abordarlos en su totalidad es un poco difícil ya que el uso que le demos va a depender de lo que querramos hacer. 

Veamos un pequeño ejemplo, cambiando de lugar la ubicación de las leyendas con el parámetro `legend.position`.

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_dark()+
  theme(legend.position = "bottom")
```

(¡Ojo! Si quiero aplicar un parámetro de la función theme manteniendo un theme predeterminado siempre tiene que ir después de él).

También existen paquetes de R que agregan a nuestro arsenal nuevos temas listos para usar, como [`ggthemes`](https://ggplot2.tidyverse.org/reference/theme.html) y [`hrbrthemes`](https://cinc.rud.is/web/packages/hrbrthemes/).

Para cerrar el tema de los temas (¡ja!) va una recomendación. El tema minimalista "theme_minimal" viene con `ggplot2` por lo que ya lo tenemos disponible y con sólo agregar la línea que lo aplica obtenemos un gráfico de aspecto más "limpio" que el del tema por default:

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_minimal()
```

¿Cómo haríamos si quisiera ver dónde se ubican los países de las Américas en este mapa?

Vamos a introducir un paquete bastante útil: `ggrepel`. Está diseñado específicamente para poder agregar etiquetas en gráficos de ggplot sin que se nos pisen entre ellas. Probemos usar su función `geom_text_repel`:

```{r}
library(ggrepel)
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() + 
  geom_text_repel(data = gapminder %>% filter(año == 2007 & continente == "Americas"), 
                  aes(x = PBIpc, y = expVida, label = pais), inherit.aes = FALSE)+
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_minimal()
```

Aquí estamos viendo algunos parámetros nuevos:

-   `label` me permite agregar las etiquetas de cada país,

-   `inherit.aes` evita que mi texto adopte los colores y formas de la primera línea.

## Título, sub-título, etiquetas, leyendas y notas al pie

En el contexto de la exploración de los datos, lo importante es trabajar en forma rápida. Probamos una u otra técnica de visualización y refinamos nuestros resultados hasta hallar patrones interesantes o sacarnos dudas acerca del contenido. No necesitamos ponerle título a las visualizaciones porque ya sabemos de que tratan (¡acabamos de escribirlas!). No nos preocupa que los nombres de los ejes indiquen en forma clara la variable representan porque ya lo sabemos de antemano.

Sin embargo, cuando queremos guardar un gráfico para compartir con otras personas, sea publicándolo en un *paper* o enviándolo por email a colegas, necesitamos tener más cuidado. Hemos pasado del ámbito de la exploración al de la comunicación. Ahora si nos importa la claridad porque no sabemos de antemano cuánta familiaridad tiene con los datos la eventual audiencia.

Si bien la comunicación clara es un arte cuyas reglas dependen del contexto y además cada quien tiene su estilo, podemos mencionar al menos tres elementos que no deberían faltar en un gráfico pensado para compartir:

-   Un título descriptivo, pero breve.
-   Etiquetas claras (no ambiguas) en los ejes
-   Nombres descriptivos en las leyendas

y ya que estamos, dos opcionales:

-   Un subtítulo donde poner detalles importantes que no entran en un título breve
-   Una nota al pie con información adicional: fuente de los datos, cita académica, advertencias, etc.

Todo ello puede resolverse con la misma función: `labs()`. Esta se encarga de definir título y subtítulo, nombres de ejes y de leyendas y nota al pie si hiciera falta.

Empecemos por título y subtítulo, que se asignan con los parámetros *title* y *subtitle*. Pidamos que el título sea "Riqueza vs. salud en los países del mundo", y el subtítulo, "según datos 2007":

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_minimal() +
  labs(title = "Riqueza vs. salud en los países del mundo", subtitle = "según datos 2007")
```

Ahora mejoremos las etiquetas de los ejes y el tamañno de la leyenda. La leyenda dec color está bien así, la vamos a dejar en paz. El parámetro de `labs()` para definir el nombre que llevaran las $x$ es *x* (como `labs(x  = "nombre para el eje de las x")`). El parámetro para las $y$ es *y*. El que fija el título de la leyenda de tamaño es *size*, y así con el resto de las leyendas: *color*, *shape*, o el atributo que hayamos definido dentro de `aes()` al hacer el gráfico.

Pongamos "población (millones)" como título de la leyenda de tamaño, "PBI per capita (USD)" en las $x$ y "expectativa de vida en años" en las $y$:

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida)) +
  geom_point(aes(size = pobl/1000000, color = continente)) +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_minimal() +
  labs(title = "Riqueza vs. salud en los países del mundo", 
       subtitle = "según datos 2007",
       size = "población (millones)", 
       x = "PBI per capita (USD)", 
       y = "expectativa de vida en años")

```


Con el paquete **ggtext** también puedo formatear con Markdown el texto que aparece: 

```{r}
library(ggtext)

ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida)) +
  geom_point(aes(size = pobl/1000000, color = continente)) +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_minimal() +
  labs(title = "Riqueza vs. salud en los países del mundo", 
       subtitle = "según datos 2007",
       size = "población (millones)", 
       x = "**PBI per capita** (USD)", 
       y = "**expectativa de vida** en años")+
 theme(plot.title = element_markdown(face = 'bold'),
 axis.title.x = element_markdown(),
 axis.title.y = element_markdown())

```


Y por último, una nota al pie con la fuente de los datos, vía *caption* :

```{r}
ggplot(filter(gapminder, año == 2007), 
       aes(x = PBIpc, y = expVida, size = pobl/1000000, color = continente)) +
  geom_point() +
  scale_x_log10() +
  scale_colour_manual(values = color_continentes) + 
  theme_minimal() +
  labs(title = "Riqueza vs. salud en los países del mundo", subtitle = "según datos 2007",
       size = "población (millones)", 
       x = "**PBI per capita** (USD)", 
       y = "**expectativa de vida** en años",
       caption = "*fuente: Gapminder*") +
   theme(plot.title = element_markdown(face = 'bold'),
         plot.caption = element_markdown(lineheight = 1.2),
   axis.title.x = element_markdown(),
   axis.title.y = element_markdown())


ggsave('grafico_gapminder.png', width = 8, height = 5)
```


¡Hasta la próxima!

